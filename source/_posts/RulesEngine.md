title: RulesEngine
date: 2016-06-17 13:30:27
tags: [dsl, rule engine]
---


# the translation or Martin Fowler's article

## 原文链接(http://martinfowler.com/bliki/RulesEngine.html)


我是否应该使用规则引擎?

规则引擎提供了非传统的计算模型。它没有使用通常的命令模型，
而是集合了一系列的带有条件和循环的命令，每个规则引擎都应该基于一个规则系统()。
规则系统是一系统生产环境的规则的集合，每个规则都包含了各自的条件和动作-你可以简单地把它看成if-then语句。


它的微妙之处就在于规则可以用任何顺序来定义，引擎决定什么时候用什么顺序来让规则产生真实意义。
换个说法，引擎遍历所有的规则，根据条件选择某条规则，然后根据是否满足条件来决定要不要执行动作。
非常棒的是很多问题都适用于这个模型:

```
if car.owner.hasCellPhone then premium += 100;
if car.model.theftRating > 4 then premium += 200;
if car.owner.livesInDodgyArea && car.model.theftRating > 2 then premium += 300;
```

规则引擎就是一个让我们利用这种计算模型来更容易编辑的工具。它可能是个完成的开发环境，
或者是一个可以在传统平台上工作的框架。这些年我见过的最多的就是集成在某个已经存在的平台的工具。
曾经很流行把规则引擎做成一套系统，但是现在人们(明智地)倾向于在系统的某个模块使用规则引擎。
生产上的规则计算模型更适合来解决一部分计算问题，所以规则引擎更适合嵌入到大型系统。


你可以选择自己构建一个小型的规则引擎。你所要做的就是：创建一批带着条件和动作的对象，把它们存起来，
遍历它们并判断是否符合条件来决定要不要执行动作。但是大多时候人们提起来规则引擎，他们实际上指的
是一个能帮你构建运行规则引擎的产品。实现规则的技术手段可以从一个把规则描述为Java对象的API，到
DSL语言，或者一个允许用户输入规则的GUI。更有效的执行引擎可以通过特殊的算法(比如RETE算法)在几百个规则中快速
判断条件。


规则引擎很重要的一个属性是调用链- 当规则的动作改变了系统状态，它会更改其它规则的条件部份。
调用链听起来很吸引人，因为它支持更复杂的行为，但会轻易地结束运行 being very hard to reason about and debug。


我碰到过一些人利用规则引擎做出的产品【】。通常情况下规则引擎的核心是允许业务人员自己定义规则，所以
他们可以构建规则而不用麻烦开发者。这听起来似乎很美好但实际上很难做到。


即使如此，业务人员可读懂的DSL仍然有价值，而且我认为是这个计算模型的价值所在。但是这里像躺着一头恶龙。
最大的是当你看规则列表来排查哪条规则有什么用时，有调用链关系的规则会非常复杂。所以我经常听说做一个
规则系统很简单，但难的是维护它因为没有人能理解这么不清晰的程序流。这是不用命令计算模型的不好的一面。
对于命令式语句的错来说，很容易去理解它怎么运行的。对于一个生产上的规则系统，很容易因为某一处的改动
引起意外，很难像预料中一样运行。


我并没有花很多时间从这些系统上得到任何启示来控制一些不明显的行为

* 限制规则的数量很重要，实际上任何有足够规则的系统都需要优秀的算法来保证性能,很可能是太多的规则难以理解。
* 小心利用调用链，最好经常组织规则来限制甚至消除调用链。
* 就像在很多地方一样，测试总是被低估，但不明显的行为让测试更加重要 - 而且它需要和生产数据一起。
* 当构建一个规则系统时，我更希望看到通过减少规则库来尽早引发问题。


以上的这些让我思考关于避免规则引擎产品应该说些什么。关于生产规则的基础主意是很简单的。为了保持
不明显行为在控制下你还得把规则限制在一个狭窄的上下文里。这里会争论出一个更加领域化的规则，
一个团队构建了一个只工作在有限范围内的规则引擎。当然如果你在考虑是否要用规则引擎，我建议你可以
先根据产品和领域特定方法来做原型，这样你可以很好的比较。


如果需要更多信息，可以看我的《Domain-Specific Languages》中的 Production Rules System一章。
